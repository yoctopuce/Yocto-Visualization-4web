/* Yocto-Visualization-4web installer (version 1.10.57386) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_FILE_NOT_FOUND = -14;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(YAPIContext.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.lastPingStamp = 0;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._knownUrls.push(urlInfo.orgUrl);
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < this.stalledTimeoutMs;
  }
  imm_isForwarded() {
    return false;
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.orgUrl)) {
      this._knownUrls.push(urlInfo.orgUrl);
    }
    if (this.urlInfo.authUrl == urlInfo.authUrl) {
      this.urlInfo = urlInfo;
      return;
    }
    this.urlInfo = urlInfo;
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.rootUrl);
      }
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.rootUrl + ", dropping connection to " + otherHub.urlInfo.rootUrl);
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.rootUrl);
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.rootUrl + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.rootUrl);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = "/" + this.urlInfo.domain + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg) => {
        resolve({errorType, errorMsg});
      });
    });
  }
  async reconnect(tryOpenID) {
    this.currentConnID = tryOpenID;
    if (!this.hubSerial || this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
        if (this.infoJson && this.infoJson.serialNumber) {
          this.hubSerial = this.infoJson.serialNumber;
        }
      } else if (res_struct.errorType == YAPI_FILE_NOT_FOUND) {
        res_struct = await this.tryFetch("api/module/serialNumber");
        if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
          this.hubSerial = res_struct.result;
        }
      }
      if (!this.hubSerial) {
        if (!super.imm_disconnectNow(tryOpenID)) {
          return;
        }
        if (!this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Failed to load info.json: " + res_struct.errorMsg + " [" + tryOpenID + "]");
          }
        }
        this._lastErrorType = res_struct.errorType;
        this._lastErrorMsg = res_struct.errorMsg;
        this.currentConnID = "";
        this.imm_signalHubDisconnected(tryOpenID);
        return;
      }
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub !== this) {
      this.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected");
      this.currentConnID = "";
      this.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this.notifPos >= 0) {
      args = "?abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "not.byn" + args, null, (moreText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._currentState < 0) {
        this.signalHubConnected(tryOpenID, this.hubSerial);
      }
      this._yapi.parseEvents(this, moreText);
    }, (resultText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnect(tryOpenID);
    }, (errorType, errorMsg) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this.imm_isDisconnecting()) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._lastErrorType = errorType;
      this._lastErrorMsg = errorMsg;
      if (errorType == YAPI_UNAUTHORIZED) {
        this.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this.imm_disconnectNow();
    });
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.notbynRequest) {
      return false;
    }
    let closeConnID = connID ? connID : this.currentConnID;
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this.currentConnID = "";
    this.imm_signalHubDisconnected(closeConnID);
    return true;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._currentState < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl.slice(1), obj_body, null, (responseText) => {
        if (this._currentState < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg) => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.rootUrl);
  }
  async reconnect(tryOpenID) {
    this._connectionState = 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this.currentConnID = tryOpenID;
    this.imm_webSocketOpen(this.urlInfo.authUrl + "not.byn");
    this._firstArrivalCallback = true;
    if (!this.websocket) {
      this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._lastErrorType = YAPI_IO_ERROR;
          this._lastErrorMsg = errMsg;
        }
        this.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this.currentConnID + "]");
        }
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
        this._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        this._lastErrorType = YAPI_IO_ERROR;
        this._lastErrorMsg = evt.message;
      }
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_disconnectNow();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        this._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        this.imm_disconnectNow();
      }
    }, this.stalledTimeoutMs);
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.websocket) {
      return false;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this.currentConnID;
    let websocket = this.websocket;
    this.currentConnID = "";
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this.imm_signalHubDisconnected(prevOpenID);
    return true;
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.urlInfo.orgUrl;
      case "connectionUrl":
        return hub.urlInfo.rootUrl;
      case "serialNumber":
        return hub.hubSerial;
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.stalledTimeoutMs;
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.stalledTimeoutMs = value;
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    return this._knownHubsByUrl[obj_urlInfo.rootUrl];
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.hubSerial];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.hubSerial] = hub;
      this._knownHubsByUrl[hub.urlInfo.rootUrl] = hub;
      return hub;
    }
    if (primaryHub._currentState >= hub._currentState) {
      primaryHub.imm_inheritFrom(hub);
      return primaryHub;
    }
    this._knownHubsBySerial[hub.hubSerial] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.rootUrl];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.rootUrl, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].urlInfo.rootUrl;
      if (newhub.urlInfo.rootUrl == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.urlInfo.rootUrl;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub._currentState < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.rootUrl;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub._firstArrivalCallback ? ", firstArrival" : ""));
      }
      if (currdev && hub._firstArrivalCallback) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.rootUrl.length) == hub.urlInfo.rootUrl) {
      devUrl = baseUrl.substr(hub.urlInfo.rootUrl.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.rootUrl;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.57386";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub._currentState > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let org_url = str_url;
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    let rooturl = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/") {
        dom += "/";
      }
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http://") {
          port = "80";
        } else if (proto == "https://") {
          port = "443";
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
      rooturl = url;
    } else {
      url += host + ":" + port + "/" + dom;
      rooturl = proto + host + ":" + port + "/" + dom;
    }
    return {
      proto,
      user,
      pass,
      host,
      port,
      domain: dom,
      authUrl: url,
      rootUrl: rooturl,
      orgUrl: org_url
    };
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    if (newhub) {
      this._knownHubsByUrl[urlInfo.rootUrl] = newhub;
    }
    return newhub;
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    return this._connectedHubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      if (hub.hubSerial) {
        let activeHub = this._knownHubsBySerial[hub.hubSerial];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.rootUrl + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + urlInfo.rootUrl);
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == nextref) {
        if (hub.imm_isPreOrRegistered()) {
          return this.getYHubObj(nextref);
        } else {
          nextref++;
        }
      }
    }
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YHttpHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this.urlInfo.authUrl + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")");
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)");
          } else if (this.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting");
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status);
          }
          return;
        }
        if (this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status");
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.57386";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (sensorsManager._customArrivalCallback != null)
      sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._customRemovalCallback != null)
      sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
