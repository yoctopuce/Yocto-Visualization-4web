/* Yocto-Visualization-4web installer (version 1.10.55367) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_FILE_NOT_FOUND = -14;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.lastPingStamp = 0;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._knownUrls.push(urlInfo.orgUrl);
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < this.stalledTimeoutMs;
  }
  imm_isForwarded() {
    return false;
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.orgUrl)) {
      this._knownUrls.push(urlInfo.orgUrl);
    }
    if (this.urlInfo.authUrl == urlInfo.authUrl) {
      this.urlInfo = urlInfo;
      return;
    }
    this.urlInfo = urlInfo;
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.rootUrl);
      }
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.rootUrl + ", dropping connection to " + otherHub.urlInfo.rootUrl);
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.rootUrl);
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.rootUrl + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.rootUrl);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = "/" + this.urlInfo.domain + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg) => {
        resolve({errorType, errorMsg});
      });
    });
  }
  async reconnect(tryOpenID) {
    this.currentConnID = tryOpenID;
    if (!this.hubSerial || this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
        if (this.infoJson && this.infoJson.serialNumber) {
          this.hubSerial = this.infoJson.serialNumber;
        }
      } else if (res_struct.errorType == YAPI_FILE_NOT_FOUND) {
        res_struct = await this.tryFetch("api/module/serialNumber");
        if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
          this.hubSerial = res_struct.result;
        }
      }
      if (!this.hubSerial) {
        if (!super.imm_disconnectNow(tryOpenID)) {
          return;
        }
        if (!this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Failed to load info.json: " + res_struct.errorMsg + " [" + tryOpenID + "]");
          }
        }
        this._lastErrorType = res_struct.errorType;
        this._lastErrorMsg = res_struct.errorMsg;
        this.currentConnID = "";
        this.imm_signalHubDisconnected(tryOpenID);
        return;
      }
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub !== this) {
      this.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected");
      this.currentConnID = "";
      this.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this.notifPos >= 0) {
      args = "?abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "not.byn" + args, null, (moreText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._currentState < 0) {
        this.signalHubConnected(tryOpenID, this.hubSerial);
      }
      this._yapi.parseEvents(this, moreText);
    }, (resultText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnect(tryOpenID);
    }, (errorType, errorMsg) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this.imm_isDisconnecting()) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._lastErrorType = errorType;
      this._lastErrorMsg = errorMsg;
      if (errorType == YAPI_UNAUTHORIZED) {
        this.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this.imm_disconnectNow();
    });
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.notbynRequest) {
      return false;
    }
    let closeConnID = connID ? connID : this.currentConnID;
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this.currentConnID = "";
    this.imm_signalHubDisconnected(closeConnID);
    return true;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._currentState < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl.slice(1), obj_body, null, (responseText) => {
        if (this._currentState < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg) => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.rootUrl);
  }
  async reconnect(tryOpenID) {
    this._connectionState = 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this.currentConnID = tryOpenID;
    this.imm_webSocketOpen(this.urlInfo.authUrl + "not.byn");
    this._firstArrivalCallback = true;
    if (!this.websocket) {
      this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._lastErrorType = YAPI_IO_ERROR;
          this._lastErrorMsg = errMsg;
        }
        this.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this.currentConnID + "]");
        }
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
        this._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        this._lastErrorType = YAPI_IO_ERROR;
        this._lastErrorMsg = evt.message;
      }
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_disconnectNow();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        this._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        this.imm_disconnectNow();
      }
    }, this.stalledTimeoutMs);
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.websocket) {
      return false;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this.currentConnID;
    let websocket = this.websocket;
    this.currentConnID = "";
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this.imm_signalHubDisconnected(prevOpenID);
    return true;
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.urlInfo.orgUrl;
      case "connectionUrl":
        return hub.urlInfo.rootUrl;
      case "serialNumber":
        return hub.hubSerial;
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.stalledTimeoutMs;
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.stalledTimeoutMs = value;
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    return this._knownHubsByUrl[obj_urlInfo.rootUrl];
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.hubSerial];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.hubSerial] = hub;
      this._knownHubsByUrl[hub.urlInfo.rootUrl] = hub;
      return hub;
    }
    if (primaryHub._currentState >= hub._currentState) {
      primaryHub.imm_inheritFrom(hub);
      return primaryHub;
    }
    this._knownHubsBySerial[hub.hubSerial] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.rootUrl];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.rootUrl, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].urlInfo.rootUrl;
      if (newhub.urlInfo.rootUrl == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.urlInfo.rootUrl;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub._currentState < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.rootUrl;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub._firstArrivalCallback ? ", firstArrival" : ""));
      }
      if (currdev && hub._firstArrivalCallback) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.rootUrl.length) == hub.urlInfo.rootUrl) {
      devUrl = baseUrl.substr(hub.urlInfo.rootUrl.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.rootUrl;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.55367";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub._currentState > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let org_url = str_url;
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    let rooturl = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/") {
        dom += "/";
      }
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http://") {
          port = "80";
        } else if (proto == "https://") {
          port = "443";
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
      rooturl = url;
    } else {
      url += host + ":" + port + "/" + dom;
      rooturl = proto + host + ":" + port + "/" + dom;
    }
    return {
      proto,
      user,
      pass,
      host,
      port,
      domain: dom,
      authUrl: url,
      rootUrl: rooturl,
      orgUrl: org_url
    };
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    if (newhub) {
      this._knownHubsByUrl[urlInfo.rootUrl] = newhub;
    }
    return newhub;
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    return this._connectedHubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      if (hub.hubSerial) {
        let activeHub = this._knownHubsBySerial[hub.hubSerial];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.rootUrl + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + urlInfo.rootUrl);
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == nextref) {
        if (hub.imm_isPreOrRegistered()) {
          return this.getYHubObj(nextref);
        } else {
          nextref++;
        }
      }
    }
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YHttpHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this.urlInfo.authUrl + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")");
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)");
          } else if (this.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting");
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status);
          }
          return;
        }
        if (this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status");
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.55367";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
