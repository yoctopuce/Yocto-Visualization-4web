<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<i>results are shown in the browser console</i>
</body>
<script  type='module' src="./pako_original.js"></script>
<script type="module">


    
import * as YPAKO  from './pako/Pako_full.js';
import {tester} from './pako/_testTools.js';

tester.mainrun('Inflate states', () => {
    //in port checking input parameters was removed
    tester.run('inflate bad parameters', () => {

        let ret = YPAKO.zlib_inflate.inflate(null, 0);
        tester.assert(ret === YPAKO.zlib_constants.Z_STREAM_ERROR,"ret != YPAKO.zlib_constants.Z_STREAM_ERROR");

        ret = YPAKO.zlib_inflate.inflateEnd(null);
        tester.assert(ret === YPAKO.zlib_constants.Z_STREAM_ERROR,"ret != YPAKO.zlib_constants.Z_STREAM_ERROR");

        //skip: inflateCopy is not implemented
        //ret = zlib_inflate.inflateCopy(null, null);
        //assert(ret == YPAKO.zlib_constants.Z_STREAM_ERROR);
    });
    tester.run('bad gzip method', () => {
        tester.testInflate2('1f 8b 0 0', 31, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('bad gzip flags', () => {
        tester.testInflate2('1f 8b 8 80', 31, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('bad zlib method', () => {
        tester.testInflate2('77 85', 15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('set window size from header', () => {
        tester.testInflate2('8 99', 0, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('bad zlib window size', () => {
        tester.testInflate2('78 9c', 8, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('check adler32', () => {
        tester.testInflate2('78 9c 63 0 0 0 1 0 1', 15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('bad header crc', () => {
        tester.testInflate2('1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0', 47, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('check gzip length', () => {
        tester.testInflate2('1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0', 47, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('bad zlib header check', () => {
        tester.testInflate2('78 90', 47, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('need dictionary', () => {
        tester.testInflate2('8 b8 0 0 0 1', 8, YPAKO.zlib_constants.Z_NEED_DICT);
    });
    tester.run('compute adler32', () => {
        tester.testInflate2('78 9c 63 0', 15, YPAKO.zlib_constants.Z_OK);
    });
});

tester.mainrun('Inflate cover', () => {
    tester.run('invalid stored block lengths', () => {
        tester.testInflate2('0 0 0 0 0', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('fixed', () => {
        tester.testInflate2('3 0', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('invalid block type', () => {
        tester.testInflate2('6', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('stored', () => {
        tester.testInflate2('1 1 0 fe ff 0', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('too many length or distance symbols', () => {
        tester.testInflate2('fc 0 0', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid code lengths set', () => {
        tester.testInflate2('4 0 fe ff', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid bit length repeat', () => {
        tester.testInflate2('4 0 24 49 0', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid bit length repeat', () => {
        tester.testInflate2('4 0 24 e9 ff ff', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid code -- missing end-of-block', () => {
        tester.testInflate2('4 0 24 e9 ff 6d', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid literal/lengths set', () => {
        tester.testInflate2('4 80 49 92 24 49 92 24 71 ff ff 93 11 0', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid literal/length code', () => {
        tester.testInflate2('4 80 49 92 24 49 92 24 f b4 ff ff c3 84', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid distance code', () => {
        tester.testInflate2('2 7e ff ff', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('invalid distance too far back', () => {
        tester.testInflate2('c c0 81 0 0 0 0 0 90 ff 6b 4 0', -15, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('incorrect data check', () => {
        tester.testInflate2('1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1', 47, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('incorrect length check', () => {
        tester.testInflate2('1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1', 47, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('pull 17', () => {
        tester.testInflate2('5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('long code', () => {
        tester.testInflate2('5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('length extra', () => {
        tester.testInflate2('ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('long distance and extra', () => {
        tester.testInflate2('ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('window end', () => {
        tester.testInflate2('ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6',
            -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('inflate_fast TYPE return', () => {
        tester.testInflate2('2 8 20 80 0 3 0', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('window wrap', () => {
        tester.testInflate2('63 18 5 40 c 0', -8, YPAKO.zlib_constants.Z_OK);
    });
});

tester.mainrun('cover trees', () => {
    tester.run('inflate_table not enough errors', () => {
        let ret, bits, next, table = [], lens = [], work = [];
        const DISTS = 2;
        /* we need to call inflate_table() directly in order to manifest not-
         enough errors, since zlib insures that enough is always enough */
        for (bits = 0; bits < 15; bits++) {
            lens[bits] = bits + 1;
        }
        lens[15] = 15;
        next = table;

        ret = YPAKO.zlib_inftrees.inflate_table(DISTS, lens, 0, 16, next, 0, work, { bits: 15 });
        tester.assert(ret === 1,"ret != 1");

        next = table;
        ret = YPAKO.zlib_inftrees.inflate_table(DISTS, lens, 0, 16, next, 0, work, { bits: 1 });
        tester.assert(ret === 1,"ret != 1");
    });
});

tester.mainrun('Inflate fast', () => {
    tester.run('fast length extra bits', () => {
        tester.testInflate2('e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68' +
            ' ff 7f 0f 0 0 0', -8, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('fast distance extra bits', () => {
        tester.testInflate2('25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49' +
            ' 50 fe ff ff 3f 0 0', -8, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('fast invalid literal/length code', () => {
        tester.testInflate2('1b 7 0 0 0 0 0', -8, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('fast 2nd level codes and too far back', () => {
        tester.testInflate2('d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0', -8, YPAKO.zlib_constants.Z_DATA_ERROR);
    });
    tester.run('very common case', () => {
        tester.testInflate2('63 18 5 8c 10 8 0 0 0 0', -8, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('contiguous and wrap around window', () => {
        tester.testInflate2('63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0', -8, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('copy direct from output', () => {
        tester.testInflate2('63 0 3 0 0 0 0 0', -8, YPAKO.zlib_constants.Z_OK);
    });
});

tester.mainrun('Inflate support', () => {
    // `inflatePrime` not implemented
    /*it('prime', function() {
      let ret;
      const strm = new zlib_stream();
      strm.avail_in = 0;
      strm.input = null;

      ret = zlib_inflate.inflateInit(strm);
      assert(ret === YPAKO.zlib_constants.Z_OK);

      ret = zlib_inflate.inflatePrime(strm, 5, 31);
      assert(ret === YPAKO.zlib_constants.Z_OK);

      ret = zlib_inflate.inflatePrime(strm, -1, 0);
      assert(ret === YPAKO.zlib_constants.Z_OK);

      // `inflateSetDictionary` not implemented
      // ret = zlib_inflate.inflateSetDictionary(strm, null, 0);
      // assert(ret === YPAKO.zlib_constants.Z_STREAM_ERROR);

      ret = zlib_inflate.inflateEnd(strm);
      assert(ret === YPAKO.zlib_constants.Z_OK);
    });*/
    tester.run('force window allocation', () => {
        tester.testInflate2('63 0', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('force window replacement', () => {
        tester.testInflate2('63 18 5', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('force split window update', () => {
        tester.testInflate2('63 18 68 30 d0 0 0', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('use fixed blocks', () => {
        tester.testInflate2('3 0', -15, YPAKO.zlib_constants.Z_OK);
    });
    tester.run('bad window size', () => {
        tester.testInflate2('', -15, YPAKO.zlib_constants.Z_OK);
    });
});

console.log("Done.")




</script>

</html>

