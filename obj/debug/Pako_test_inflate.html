<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<i>results are shown in the browser console</i>
</body>
<script  type='module' src="./pako_original.js"></script>
<script type="module">


    
import * as YPAKO  from './pako/Pako_full.js';
import {tester} from './pako/_testTools.js';


const samples = await tester.loadSamples();

tester.mainrun('Inflate defaults', () => {

    tester.run('inflate, no options', () => {
        tester.testInflate(samples, {}, {});
    });

    tester.run('inflate raw, no options', () => {
        tester.testInflate(samples, { raw: true }, { raw: true });
    });

    tester.run('inflate raw from compressed samples', async () => {
        const compressed_samples =  await tester.loadSamples('samples_deflated_raw');
        tester.testSamples(window.pako.inflateRaw, pako.inflateRaw, compressed_samples, {});
    });

});


tester.mainrun('Inflate ungzip', () => {
    tester.run('with autodetect', () => {
        tester.testInflate(samples, {}, { gzip: true });
    });

    tester.run('with method set directly', () => {
        tester.testInflate(samples, { windowBits: 16 }, { gzip: true });
    });
});


tester.mainrun('Inflate levels', () => {

    tester.run('level 9', () => {
        tester.testInflate(samples, {}, { level: 9 });
    });
    tester.run('level 8', () => {
        tester.testInflate(samples, {}, { level: 8 });
    });
    tester.run('level 7', () => {
        tester.testInflate(samples, {}, { level: 7 });
    });
    tester.run('level 6', () => {
        tester.testInflate(samples, {}, { level: 6 });
    });
    tester.run('level 5', () => {
        tester.testInflate(samples, {}, { level: 5 });
    });
    tester.run('level 4', () => {
        tester.testInflate(samples, {}, { level: 4 });
    });
    tester.run('level 3', () => {
        tester.testInflate(samples, {}, { level: 3 });
    });
    tester.run('level 2', () => {
        tester.testInflate(samples, {}, { level: 2 });
    });
    tester.run('level 1', () => {
        tester.testInflate(samples, {}, { level: 1 });
    });
    tester.run('level 0', () => {
        tester.testInflate(samples, {}, { level: 0 });
    });

});


tester.mainrun('Inflate windowBits', () => {

    tester.run('windowBits 15', () => {
        tester.testInflate(samples, {}, { windowBits: 15 });
    });
    tester.run('windowBits 14', () => {
        tester.testInflate(samples, {}, { windowBits: 14 });
    });
    tester.run('windowBits 13', () => {
        tester.testInflate(samples, {}, { windowBits: 13 });
    });
    tester.run('windowBits 12', () => {
        tester.testInflate(samples, {}, { windowBits: 12 });
    });
    tester.run('windowBits 11', () => {
        tester.testInflate(samples, {}, { windowBits: 11 });
    });
    tester.run('windowBits 10', () => {
        tester.testInflate(samples, {}, { windowBits: 10 });
    });
    tester.run('windowBits 9', () => {
        tester.testInflate(samples, {}, { windowBits: 9 });
    });
    tester.run('windowBits 8', () => {
        tester.testInflate(samples, {}, { windowBits: 8 });
    });

});

tester.mainrun('Inflate strategy', () => {

    tester.run('Z_DEFAULT_STRATEGY', () => {
        tester.testInflate(samples, {}, { strategy: 0 });
    });
    tester.run('Z_FILTERED', () => {
        tester.testInflate(samples, {}, { strategy: 1 });
    });
    tester.run('Z_HUFFMAN_ONLY', () => {
        tester.testInflate(samples, {}, { strategy: 2 });
    });
    tester.run('Z_RLE', () => {
        tester.testInflate(samples, {}, { strategy: 3 });
    });
    tester.run('Z_FIXED', () => {
        tester.testInflate(samples, {}, { strategy: 4 });
    });

});


tester.mainrun('Inflate RAW', () => {
    // Since difference is only in rwapper, test for store/fast/slow methods are enough
    tester.run('level 9', () => {
        tester.testInflate(samples, { raw: true }, { level: 9, raw: true });
    });
    tester.run('level 8', () => {
        tester.testInflate(samples, { raw: true }, { level: 8, raw: true });
    });
    tester.run('level 7', () => {
        tester.testInflate(samples, { raw: true }, { level: 7, raw: true });
    });
    tester.run('level 6', () => {
        tester.testInflate(samples, { raw: true }, { level: 6, raw: true });
    });
    tester.run('level 5', () => {
        tester.testInflate(samples, { raw: true }, { level: 5, raw: true });
    });
    tester.run('level 4', () => {
        tester.testInflate(samples, { raw: true }, { level: 4, raw: true });
    });
    tester.run('level 3', () => {
        tester.testInflate(samples, { raw: true }, { level: 3, raw: true });
    });
    tester.run('level 2', () => {
        tester.testInflate(samples, { raw: true }, { level: 2, raw: true });
    });
    tester.run('level 1', () => {
        tester.testInflate(samples, { raw: true }, { level: 1, raw: true });
    });
    tester.run('level 0', () => {
        tester.testInflate(samples, { raw: true }, { level: 0, raw: true });
    });

});


tester.mainrun('Inflate with dictionary', () => {

    tester.run('should throw on the wrong dictionary', () => {
        // const zCompressed = helpers.deflateSync('world', { dictionary: Buffer.from('hello') });
        const zCompressed = new Uint8Array([ 120, 187, 6, 44, 2, 21, 43, 207, 47, 202, 73, 1, 0, 6, 166, 2, 41 ]);

        tester.assertThrows (function () {
            pako.inflate(zCompressed, { dictionary: 'world' });
        }, 'need dictionary');
    });

    tester.run('trivial dictionary', () => {
        const dict =  tester.Buffer_from_string('abcdefghijklmnoprstuvwxyz');
        tester.testInflate(samples, { dictionary: dict }, { dictionary: dict});
    });

    tester.run('spdy dictionary',async () => {
        const spdyDict = await tester.LoadFile('pako/fixtures/spdy_dict.txt');
        tester.testInflate(samples, { dictionary: spdyDict }, { dictionary: spdyDict });
    });

    tester.run('should throw if directory is not supplied to raw inflate', () => {
        const dict =  tester.Buffer_from_string('abcdefghijklmnoprstuvwxyz');
        tester.assertThrows (function () {
            tester.testInflate(samples, { raw: true }, { raw: true, dictionary: dict });
        },'no directory' );
    });

    tester.run('tests raw inflate with spdy dictionary', async () => {
        const spdyDict = await tester.LoadFile('pako/fixtures/spdy_dict.txt');
        tester.testInflate(samples, { raw: true, dictionary: spdyDict }, { raw: true, dictionary: spdyDict });
    });

    tester.run('tests dictionary as Uint8Array', () => {
        const dict = new Uint8Array(100);
        for (let i = 0; i < 100; i++) dict[i] = Math.random() * 256;
        tester.testInflate(samples, { dictionary: dict }, { dictionary: dict });
    });

    tester.run('tests dictionary as ArrayBuffer', () => {
        const dict = new Uint8Array(100);
        for (let i = 0; i < 100; i++) dict[i] = Math.random() * 256;
        tester.testInflate(samples, { dictionary: dict.buffer }, { dictionary: dict });
    });
});


tester.mainrun('pako patches for inflate', () => {

    tester.run('Force use max window size by default', async() => {
        const data =  await tester.LoadFile('pako/fixtures/bad_wbits.deflate');
        const unpacked = await tester.LoadFile('pako/fixtures/bad_wbits.txt');

        tester.assertEqual(pako.inflate(data), new Uint8Array(unpacked));
    });
});
console.log("Done.")

</script>

</html>

